## 电影模块后端接口文档（Spring Boot 实现导向）

本文档基于当前前端实现对齐生成，覆盖电影搜索与联想接口，并给出 Spring Boot 控制器 / DTO / Service 设计要点，确保与前端请求参数、响应结构完全匹配。

### 一、前端约定与网关
- 基础路径：`/api`（前端通过 `https://filmforum.billadom.top/api` 访问）
- 凭证策略：`credentials: include`（后端需正确配置跨域并下发/接收 Cookie）
- CSRF：前端仅在有请求体时携带 `X-CSRF-TOKEN`。本模块均为 GET 请求，无需 CSRF 校验。

### 二、数据契约（与前端类型严格对齐）

1) 搜索请求参数（QueryString）
- `q`：string，关键词，可空
- `genres`：string，逗号分隔的类型列表，如 `动作,科幻`，可空
- `regions`：string，逗号分隔的地区列表，如 `中国,香港`，可空
- `year_gte`：number，年份下限，可空
- `year_lte`：number，年份上限，可空
- `rating_gte`：number，评分下限，可空
- `rating_lte`：number，评分上限，可空
- `sort`：枚举，`relevance_desc | hot_desc | rating_desc | year_desc | updated_desc`，默认 `relevance_desc`
- `page`：number，页码，默认 1
- `page_size`：number，每页条数，默认 24

2) 搜索结果条目 SearchItem
- `id`：number
- `title`：string
- `year`：number，可空
- `rating`：number，可空
- `regions`：string[]，可空
- `genres`：string[]，可空
- `poster`：string，图片 URL，可空
- `highlight`：object，键为字段名（如 `title`），值为已包含高亮标记的 HTML 片段，可空

3) 分面与响应 SearchResponse
- `facets`：可空，对象：
  - `genres`：`[{ value: string, count: number }]`
  - `regions`：`[{ value: string, count: number }]`
  - `yearRanges`：`[{ value: string, count: number }]`（如 `2010-2014`）
  - `ratingRanges`：`[{ value: string, count: number }]`（如 `8.0-10.0`）
- `items`：SearchItem[]
- `total`：number，总条数
- `page`：number，当前页
- `pageSize`：number，每页条数
- `hasMore`：boolean，是否还有下一页
- `suggestions`：string[]，可空（当前前端未使用此字段，可忽略或返回空数组）

4) 联想 SuggestItem（`/suggest`）
- `type`：`movie | tv | anime | person | tag | list`
- `text`：展示文本
- `id`：number，可空

### 三、接口设计

#### 1. 电影搜索
- Method：GET
- Path：`/api/search`
- Query：见“搜索请求参数”

请求示例：
```
GET /api/search?q=星际&genres=科幻&regions=美国&year_gte=2000&rating_gte=7.5&sort=rating_desc&page=1&page_size=24
```

成功响应：
```json
{
  "items": [
    {
      "id": 123,
      "title": "星际穿越",
      "year": 2014,
      "rating": 8.9,
      "regions": ["美国"],
      "genres": ["科幻", "剧情"],
      "poster": "https://.../poster.jpg",
      "highlight": { "title": "<em>星际</em>穿越" }
    }
  ],
  "facets": {
    "genres": [{ "value": "科幻", "count": 120 }],
    "regions": [{ "value": "美国", "count": 300 }],
    "yearRanges": [{ "value": "2010-2014", "count": 80 }],
    "ratingRanges": [{ "value": "8.0-10.0", "count": 50 }]
  },
  "total": 1000,
  "page": 1,
  "pageSize": 24,
  "hasMore": true
}
```

错误响应（示例）：
```json
{ "code": 400, "message": "请求参数错误" }
```

排序规则建议：
- `relevance_desc`：文本相关度倒序（默认）
- `hot_desc`：热度倒序（可用浏览量/交互量）
- `rating_desc`：评分倒序
- `year_desc`：年份倒序
- `updated_desc`：数据更新时间倒序

分页规则：`hasMore = (page * page_size) < total`

字段映射建议（表 `movies`）：
- `title` -> `movies.title`
- `year` -> `movies.year`
- `rating` -> `movies.rating`
- `regions` -> `movies.country`（如需多值可拆表或使用 JSON）
- `genres` -> `movies.genre`（JSON 数组）
- `poster` -> `movies.poster`

分面统计：
- `genres`：按 `genre` JSON 展开分组计数
- `regions`：按 `country` 分组计数
- `yearRanges`：按年份区间聚合（如每 5 年一个桶）
- `ratingRanges`：按评分区间聚合（如 0.5 或 1.0 步长）

高亮生成：
- 对 `title` 命中片段以 `<em>...</em>` 包裹返回到 `highlight.title`

#### 2. 联想补全
- Method：GET
- Path：`/api/suggest`
- Query：`q: string`（关键词）

请求示例：
```
GET /api/suggest?q=阿凡
```

成功响应：
```json
[
  { "type": "movie", "text": "阿凡达", "id": 1001 },
  { "type": "person", "text": "詹姆斯·卡梅隆", "id": 2002 },
  { "type": "tag", "text": "科幻" }
]
```

### 四、Spring Boot 参考实现

#### 1) DTO 定义
```java
// Search 请求参数
public record MovieSearchQuery(
    String q,
    List<String> genres,
    List<String> regions,
    Integer yearGte,
    Integer yearLte,
    Double ratingGte,
    Double ratingLte,
    String sort,
    Integer page,
    Integer pageSize
) {}

public record FacetBucket(String value, long count) {}

public record SearchFacets(
    List<FacetBucket> genres,
    List<FacetBucket> regions,
    List<FacetBucket> yearRanges,
    List<FacetBucket> ratingRanges
) {}

public record SearchItemDto(
    Long id,
    String title,
    Integer year,
    Double rating,
    List<String> regions,
    List<String> genres,
    String poster,
    Map<String, String> highlight
) {}

public record SearchResponseDto(
    List<SearchItemDto> items,
    SearchFacets facets,
    long total,
    int page,
    int pageSize,
    boolean hasMore,
    List<String> suggestions
) {}

public record SuggestItemDto(String type, String text, Long id) {}
```

#### 2) Controller（REST）
```java
@RestController
@RequestMapping("/api")
public class MovieSearchController {

  private final MovieSearchService movieSearchService;

  public MovieSearchController(MovieSearchService movieSearchService) {
    this.movieSearchService = movieSearchService;
  }

  @GetMapping("/search")
  public SearchResponseDto search(
      @RequestParam(value = "q", required = false) String q,
      @RequestParam(value = "genres", required = false) String genres,
      @RequestParam(value = "regions", required = false) String regions,
      @RequestParam(value = "year_gte", required = false) Integer yearGte,
      @RequestParam(value = "year_lte", required = false) Integer yearLte,
      @RequestParam(value = "rating_gte", required = false) Double ratingGte,
      @RequestParam(value = "rating_lte", required = false) Double ratingLte,
      @RequestParam(value = "sort", defaultValue = "relevance_desc") String sort,
      @RequestParam(value = "page", defaultValue = "1") Integer page,
      @RequestParam(value = "page_size", defaultValue = "24") Integer pageSize
  ) {
    List<String> genreList = splitCsv(genres);
    List<String> regionList = splitCsv(regions);
    MovieSearchQuery query = new MovieSearchQuery(q, genreList, regionList, yearGte, yearLte, ratingGte, ratingLte, sort, page, pageSize);
    return movieSearchService.search(query);
  }

  @GetMapping("/suggest")
  public List<SuggestItemDto> suggest(@RequestParam("q") String q) {
    return movieSearchService.suggest(q);
  }

  private static List<String> splitCsv(String csv) {
    if (csv == null || csv.isBlank()) return List.of();
    return Arrays.stream(csv.split(",")).map(String::trim).filter(s -> !s.isEmpty()).toList();
  }
}
```

#### 3) Service 接口
```java
public interface MovieSearchService {
  SearchResponseDto search(MovieSearchQuery query);
  List<SuggestItemDto> suggest(String q);
}
```

#### 4) Repository 与索引建议
- 表：`movies`
  - 建议索引：
    - BTREE：`(year)`, `(rating)`, `(update_time)`
    - FULLTEXT（如用 MySQL 8 + InnoDB）：`(title, original_title, summary)`
  - 多值字段（`genre`, `actors`, `awards`, `photos` 等）建议：
    - 若需高效过滤/聚合，拆分为关联表；
    - 若用 JSON 存储，配合 `JSON_EXTRACT` + 虚拟列 + 索引。

#### 5) 业务规则细节
- 仅返回电影（`mediaType: movie`）。
- `highlight` 由 Service 层在命中字段生成（如命中 `title`）。
- `facets` 可按查询前置条件过滤后再计算，保证与结果一致。
- `suggest` 可合并电影/人物/标签等多源，前端会按 `type` 显示。

### 五、跨域与安全
- CORS：允许前端站点域名；`allowCredentials=true`；暴露必要头部。
- 认证：本模块为 GET，匿名可访问；登录态通过 Cookie 携带，用于其他模块。
- 速率限制：对 `/suggest` 建议开启限流（如 IP 级别 QPS）。

### 六、测试要点
- 参数覆盖：空参数、仅 `q`、仅区间过滤、异常参数（非法数字）。
- 排序正确性：每种 `sort` 都需断言顺序。
- 分页：边界页 `hasMore` 计算正确。
- 分面：分组计数在不同过滤组合下正确。

### 七、对齐校验清单（与前端）
- 路径/方法：`GET /api/search`、`GET /api/suggest`
- 参数名：完全一致（`q`、`genres`、`regions`、`year_gte`、`year_lte`、`rating_gte`、`rating_lte`、`sort`、`page`、`page_size`）
- 响应字段：`items`、`facets`、`total`、`page`、`pageSize`、`hasMore`、`highlight` 字段存在且类型匹配
- `sort` 枚举：五个值与前端一致
- 允许跨域 + 携带 Cookie


